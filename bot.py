import logging
import re
import os
from typing import Optional, Dict
from aiogram import Bot, Dispatcher, types, Router
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from sqlalchemy.sql import func
import asyncio
import os

from config import Config
from database import db
from models import User, DownloadRequest
from youtube_downloader import downloader
from storage import storage
from utils import validate_youtube_url, format_file_size, format_duration

# Configure logging
logging.basicConfig(level=getattr(logging, Config.LOG_LEVEL))
logger = logging.getLogger(__name__)

# Validate configuration
try:
    Config.validate()
except ValueError as e:
    logger.error(f"Configuration error: {e}")
    print(f"ERROR: {e}")
    print("Please check your environment variables")
    exit(1)

# Initialize bot and dispatcher
bot = Bot(token=Config.TELEGRAM_BOT_TOKEN)
dp = Dispatcher(storage=storage)
router = Router()

# States for FSM
class DownloadStates(StatesGroup):
    waiting_for_url = State()
    waiting_for_format = State()
    waiting_for_quality = State()

# Inline keyboards
def get_format_keyboard():
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(text="üé• MP4 Video", callback_data="format_mp4"),
            InlineKeyboardButton(text="üéµ MP3 Audio", callback_data="format_mp3")
        ],
        [
            InlineKeyboardButton(text="üì± WebM", callback_data="format_webm"),
            InlineKeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel")
        ]
    ])
    return keyboard

def get_quality_keyboard():
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(text="üèÜ –õ—É—á—à–µ–µ", callback_data="quality_best"),
            InlineKeyboardButton(text="üì∫ HD", callback_data="quality_hd")
        ],
        [
            InlineKeyboardButton(text="üì± –°—Ä–µ–¥–Ω–µ–µ", callback_data="quality_medium"),
            InlineKeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel")
        ]
    ])
    return keyboard

# Command handlers
@router.message(Command("start"))
async def cmd_start(message: types.Message):
    """Handle /start command"""
    user = message.from_user
    if not user:
        await message.answer("‚ùå –û—à–∏–±–∫–∞: –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω")
        return
    
    # Save user to database
    try:
        with db.get_session() as session:
            db_user = session.query(User).filter(User.telegram_id == user.id).first()
            if not db_user:
                db_user = User(
                    telegram_id=user.id,
                    username=user.username,
                    first_name=user.first_name,
                    last_name=user.last_name
                )
                session.add(db_user)
                session.commit()
            else:
                db_user.last_activity = func.now()
                session.commit()
    except Exception as e:
        logger.error(f"Database error: {e}")
        # Continue without database if there's an error
    
    welcome_text = f"""
üé¨ –ü—Ä–∏–≤–µ—Ç, {user.first_name}!

–Ø –±–æ—Ç –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è YouTube –≤–∏–¥–µ–æ. –ü—Ä–æ—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤—å –º–Ω–µ —Å—Å—ã–ª–∫—É –Ω–∞ –≤–∏–¥–µ–æ!

üìã –î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:
/start - –ù–∞—á–∞—Ç—å —Ä–∞–±–æ—Ç—É
/help - –ü–æ–º–æ—â—å
/stats - –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
/status - –°—Ç–∞—Ç—É—Å –∑–∞–≥—Ä—É–∑–æ–∫

‚ö†Ô∏è –ò—Å–ø–æ–ª—å–∑—É–π —Ç–æ–ª—å–∫–æ –¥–ª—è –ª–∏—á–Ω—ã—Ö —Ü–µ–ª–µ–π!
    """
    
    await message.answer(welcome_text)

@router.message(Command("help"))
async def cmd_help(message: types.Message):
    """Handle /help command"""
    help_text = """
üìñ –ö–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –±–æ—Ç–∞:

1Ô∏è‚É£ –û—Ç–ø—Ä–∞–≤—å —Å—Å—ã–ª–∫—É –Ω–∞ YouTube –≤–∏–¥–µ–æ
2Ô∏è‚É£ –í—ã–±–µ—Ä–∏ —Ñ–æ—Ä–º–∞—Ç (MP4, MP3, WebM)
3Ô∏è‚É£ –í—ã–±–µ—Ä–∏ –∫–∞—á–µ—Å—Ç–≤–æ
4Ô∏è‚É£ –î–æ–∂–¥–∏—Å—å –∑–∞–≥—Ä—É–∑–∫–∏

üìã –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã:
‚Ä¢ üé• MP4 - –≤–∏–¥–µ–æ —Ñ–∞–π–ª—ã
‚Ä¢ üéµ MP3 - –∞—É–¥–∏–æ —Ñ–∞–π–ª—ã  
‚Ä¢ üì± WebM - –≤–µ–± –≤–∏–¥–µ–æ

‚ö†Ô∏è –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è:
‚Ä¢ –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä: 50MB
‚Ä¢ –¢–æ–ª—å–∫–æ –¥–ª—è –ª–∏—á–Ω–æ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
‚Ä¢ –ù–µ –Ω–∞—Ä—É—à–∞–π—Ç–µ –∞–≤—Ç–æ—Ä—Å–∫–∏–µ –ø—Ä–∞–≤–∞

üÜò –ï—Å–ª–∏ —á—Ç–æ-—Ç–æ –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç:
‚Ä¢ –ü—Ä–æ–≤–µ—Ä—å –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç—å —Å—Å—ã–ª–∫–∏
‚Ä¢ –ü–æ–ø—Ä–æ–±—É–π –¥—Ä—É–≥–æ–π —Ñ–æ—Ä–º–∞—Ç
‚Ä¢ –û–±—Ä–∞—Ç–∏—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É
    """
    
    await message.answer(help_text)

@router.message(Command("stats"))
async def cmd_stats(message: types.Message):
    """Handle /stats command"""
    user = message.from_user
    if not user:
        await message.answer("‚ùå –û—à–∏–±–∫–∞: –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω")
        return
    
    try:
        with db.get_session() as session:
            db_user = session.query(User).filter(User.telegram_id == user.id).first()
            if not db_user:
                await message.answer("‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω")
                return
            
            # Get user statistics
            total_downloads = session.query(DownloadRequest).filter(
                DownloadRequest.user_id == db_user.id,
                DownloadRequest.status == "completed"
            ).count()
            
            recent_downloads = session.query(DownloadRequest).filter(
                DownloadRequest.user_id == db_user.id
            ).order_by(DownloadRequest.created_at.desc()).limit(5).all()
        
        stats_text = f"""
üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user.first_name}:

üì• –í—Å–µ–≥–æ –∑–∞–≥—Ä—É–∑–æ–∫: {total_downloads}
üìÖ –î–∞—Ç–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏: {db_user.created_at.strftime('%d.%m.%Y')}

üïê –ü–æ—Å–ª–µ–¥–Ω–∏–µ –∑–∞–≥—Ä—É–∑–∫–∏:
"""
        
        for download in recent_downloads:
            status = str(download.status)
            if status == "completed":
                status_emoji = "‚úÖ"
            elif status == "processing":
                status_emoji = "‚è≥"
            else:
                status_emoji = "‚ùå"
            stats_text += f"{status_emoji} {download.video_title[:30]}... ({status})\n"
        
        await message.answer(stats_text)
    except Exception as e:
        logger.error(f"Stats error: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏")

@router.message(Command("status"))
async def cmd_status(message: types.Message):
    """Handle /status command"""
    user = message.from_user
    if not user:
        await message.answer("‚ùå –û—à–∏–±–∫–∞: –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω")
        return
    
    try:
        with db.get_session() as session:
            db_user = session.query(User).filter(User.telegram_id == user.id).first()
            if not db_user:
                await message.answer("‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω")
                return
            
            # Get active downloads
            active_downloads = session.query(DownloadRequest).filter(
                DownloadRequest.user_id == db_user.id,
                DownloadRequest.status.in_(["pending", "processing"])
            ).all()
        
        if not active_downloads:
            await message.answer("‚úÖ –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞–≥—Ä—É–∑–æ–∫")
            return
        
        status_text = "‚è≥ –ê–∫—Ç–∏–≤–Ω—ã–µ –∑–∞–≥—Ä—É–∑–∫–∏:\n\n"
        for download in active_downloads:
            status = str(download.status)
            if status == "processing":
                status_emoji = "‚è≥"
            else:
                status_emoji = "üìã"
            status_text += f"{status_emoji} {download.video_title[:30]}... ({status})\n"
        
        await message.answer(status_text)
    except Exception as e:
        logger.error(f"Status error: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å—Ç–∞—Ç—É—Å–∞")

# Message handlers
@router.message()
async def handle_message(message: types.Message, state: FSMContext):
    """Handle all messages"""
    logger.info(f"Received message: {message.text}")
    
    if not message.text:
        await message.answer("‚ùå –û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ")
        return
        
    text = message.text.strip()
    logger.info(f"Processing text: {text}")
    
    # Check if it's a YouTube URL
    if validate_youtube_url(text):
        logger.info("Valid YouTube URL detected")
        await handle_youtube_url(message, text, state)
    else:
        logger.info("Not a YouTube URL")
        await message.answer(
            "‚ùå –≠—Ç–æ –Ω–µ –ø–æ—Ö–æ–∂–µ –Ω–∞ —Å—Å—ã–ª–∫—É YouTube. "
            "–û—Ç–ø—Ä–∞–≤—å –º–Ω–µ —Å—Å—ã–ª–∫—É –Ω–∞ YouTube –≤–∏–¥–µ–æ –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è."
        )

async def handle_youtube_url(message: types.Message, url: str, state: FSMContext):
    """Handle YouTube URL"""
    logger.info(f"Starting to handle YouTube URL: {url}")
    
    user = message.from_user
    if not user:
        await message.answer("‚ùå –û—à–∏–±–∫–∞: –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω")
        return
    
    # Check rate limiting
    if not await check_rate_limit(user.id):
        await message.answer("‚ö†Ô∏è –°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–æ–≤. –ü–æ–ø—Ä–æ–±—É–π —á–µ—Ä–µ–∑ –º–∏–Ω—É—Ç—É.")
        return
    
    # Get video info
    logger.info("Getting video info...")
    await message.answer("üîç –ü–æ–ª—É—á–∞—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –≤–∏–¥–µ–æ...")
    
    # Get video information
    try:
        video_info = downloader.get_video_info(url)
        if not video_info:
            # –í—Ä–µ–º–µ–Ω–Ω–∞—è –∑–∞–≥–ª—É—à–∫–∞ –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
            video_info = {
                'title': '–¢–µ—Å—Ç–æ–≤–æ–µ –≤–∏–¥–µ–æ',
                'duration': 120,
                'uploader': 'Test Channel'
            }
            logger.info("Using fallback video info")
    except Exception as e:
        logger.error(f"Error getting video info: {e}")
        video_info = {
            'title': '–í–∏–¥–µ–æ (–æ—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è)',
            'duration': 0,
            'uploader': 'Unknown'
        }
    
    if not video_info:
        await message.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –≤–∏–¥–µ–æ. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Å—Å—ã–ª–∫—É.")
        return
    
    logger.info(f"Video info received: {video_info['title']}")
    
    # Save URL to state
    await state.update_data(url=url, video_info=video_info)
    
    # Show format selection
    await message.answer(
        f"üìπ **{video_info['title']}**\n\n"
        f"‚è± –î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: {format_duration(video_info['duration'])}\n"
        f" –ê–≤—Ç–æ—Ä: {video_info['uploader']}\n\n"
        "–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–æ—Ä–º–∞—Ç –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è:",
        reply_markup=get_format_keyboard()
    )
    
    # Set state
    await state.set_state(DownloadStates.waiting_for_format)

# Callback query handlers
@router.callback_query(lambda c: c.data.startswith('format_'))
async def handle_format_selection(callback: types.CallbackQuery, state: FSMContext):
    """Handle format selection"""
    format_type = callback.data.replace('format_', '')
    logger.info(f"Format selected: {format_type}")
    
    await state.update_data(format_type=format_type)
    
    await callback.message.answer(
        f"üéØ –í—ã–±—Ä–∞–Ω —Ñ–æ—Ä–º–∞—Ç: {format_type.upper()}\n\n"
        "–¢–µ–ø–µ—Ä—å –≤—ã–±–µ—Ä–∏—Ç–µ –∫–∞—á–µ—Å—Ç–≤–æ:",
        reply_markup=get_quality_keyboard()
    )
    
    await state.set_state(DownloadStates.waiting_for_quality)
    await callback.answer()

@router.callback_query(lambda c: c.data.startswith('quality_'))
async def handle_quality_selection(callback: types.CallbackQuery, state: FSMContext):
    """Handle quality selection"""
    quality = callback.data.replace('quality_', '')
    logger.info(f"Quality selected: {quality}")
    
    data = await state.get_data()
    url = data.get('url', 'Unknown URL')
    format_type = data.get('format_type', 'Unknown')
    video_info = data.get('video_info', {})
    
    await callback.message.answer(
        f"üé¨ –ù–∞—á–∏–Ω–∞—é –∑–∞–≥—Ä—É–∑–∫—É!\n\n"
        f"üìπ –í–∏–¥–µ–æ: {video_info.get('title', 'Unknown')}\n"
        f"üéØ –§–æ—Ä–º–∞—Ç: {format_type.upper()}\n"
        f"‚≠ê –ö–∞—á–µ—Å—Ç–≤–æ: {quality}\n\n"
        f"‚è≥ –ó–∞–≥—Ä—É–∑–∫–∞ –Ω–∞—á–∞–ª–∞—Å—å..."
    )
    
    # Real download logic
    try:
        logger.info(f"Starting real download: {url}, format: {format_type}, quality: {quality}")
        
        # Download video
        success, file_path, download_info = await downloader.download_video_async(
            url, format_type, quality
        )
        
        if success and file_path and os.path.exists(file_path):
            file_size = os.path.getsize(file_path)
            
            # Check file size limit (50MB Telegram limit)
            if file_size > Config.MAX_FILE_SIZE:
                await callback.message.answer(
                    f"‚ùå –§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π: {format_file_size(file_size)}\n"
                    f"–ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä: {format_file_size(Config.MAX_FILE_SIZE)}"
                )
                # Clean up large file
                downloader.cleanup_file(file_path)
                await state.clear()
                await callback.answer()
                return
            
            # Save to database
            user = callback.from_user
            if user:
                try:
                    with db.get_session() as session:
                        db_user = session.query(User).filter(User.telegram_id == user.id).first()
                        if db_user:
                            download_request = DownloadRequest(
                                user_id=db_user.id,
                                youtube_url=url,
                                video_title=video_info.get('title', 'Unknown'),
                                video_duration=video_info.get('duration', 0),
                                format_type=format_type,
                                quality=quality,
                                status="completed",
                                file_path=file_path,
                                file_size=file_size
                            )
                            session.add(download_request)
                            session.commit()
                except Exception as e:
                    logger.error(f"Database error: {e}")
            
            # Send file to user
            try:
                with open(file_path, 'rb') as file:
                    if format_type == "mp3":
                        await callback.message.answer_audio(
                            audio=file,
                            title=video_info.get('title', 'Unknown'),
                            performer=video_info.get('uploader', 'Unknown'),
                            duration=int(video_info.get('duration', 0))
                        )
                    else:
                        await callback.message.answer_video(
                            video=file,
                            caption=f"üìπ {video_info.get('title', 'Unknown')}\n"
                                   f"üéØ –§–æ—Ä–º–∞—Ç: {format_type.upper()}\n"
                                   f"‚≠ê –ö–∞—á–µ—Å—Ç–≤–æ: {quality}\n"
                                   f"üìè –†–∞–∑–º–µ—Ä: {format_file_size(file_size)}"
                        )
                
                await callback.message.answer("‚úÖ –ó–∞–≥—Ä—É–∑–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!")
                
                # Clean up file after sending
                downloader.cleanup_file(file_path)
                
            except Exception as e:
                logger.error(f"Error sending file: {e}")
                await callback.message.answer(f"‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Ñ–∞–π–ª–∞: {e}")
                downloader.cleanup_file(file_path)
        else:
            await callback.message.answer("‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –≤–∏–¥–µ–æ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –¥—Ä—É–≥–æ–π —Ñ–æ—Ä–º–∞—Ç.")
            
    except Exception as e:
        logger.error(f"Download error: {e}")
        await callback.message.answer(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: {e}")
    
    await state.clear()
    await callback.answer()

@router.callback_query(lambda c: c.data == 'cancel')
async def handle_cancel(callback: types.CallbackQuery, state: FSMContext):
    """Handle cancel"""
    await callback.message.answer("‚ùå –û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞")
    await state.clear()
    await callback.answer()

async def check_rate_limit(user_id: int) -> bool:
    """Check if user has exceeded rate limit"""
    # Simple rate limiting - can be enhanced with Redis
    return True  # For now, allow all requests

async def main():
    """Main function"""
    logger.info("Starting bot...")
    
    # Include router in dispatcher
    dp.include_router(router)
    
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main()) 