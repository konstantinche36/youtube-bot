import logging
import re
from typing import Optional, Dict
from aiogram import Bot, Dispatcher, types, Router
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from sqlalchemy.sql import func
import asyncio

from config import Config
from database import db
from models import User, DownloadRequest
from youtube_downloader import downloader
from storage import storage
from utils import validate_youtube_url, format_file_size, format_duration

# Configure logging
logging.basicConfig(level=getattr(logging, Config.LOG_LEVEL))
logger = logging.getLogger(__name__)

# Validate configuration
if not Config.TELEGRAM_BOT_TOKEN:
    raise ValueError("TELEGRAM_BOT_TOKEN is required")

# Initialize bot and dispatcher
bot = Bot(token=Config.TELEGRAM_BOT_TOKEN)  # type: ignore
dp = Dispatcher()
router = Router()

# States for FSM
class DownloadStates(StatesGroup):
    waiting_for_url = State()
    waiting_for_format = State()
    waiting_for_quality = State()

# Inline keyboards
def get_format_keyboard():
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(text="üé• MP4 Video", callback_data="format_mp4"),
            InlineKeyboardButton(text="üéµ MP3 Audio", callback_data="format_mp3")
        ],
        [
            InlineKeyboardButton(text="üì± WebM", callback_data="format_webm"),
            InlineKeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel")
        ]
    ])
    return keyboard

def get_quality_keyboard():
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(text="üèÜ –õ—É—á—à–µ–µ", callback_data="quality_best"),
            InlineKeyboardButton(text="üì∫ HD", callback_data="quality_hd")
        ],
        [
            InlineKeyboardButton(text="üì± –°—Ä–µ–¥–Ω–µ–µ", callback_data="quality_medium"),
            InlineKeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel")
        ]
    ])
    return keyboard

# Command handlers
@router.message(Command("start"))
async def cmd_start(message: types.Message):
    """Handle /start command"""
    user = message.from_user
    if not user:
        await message.answer("‚ùå –û—à–∏–±–∫–∞: –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω")
        return
    
    # Save user to database
    with db.get_session() as session:
        db_user = session.query(User).filter(User.telegram_id == user.id).first()
        if not db_user:
            db_user = User(
                telegram_id=user.id,
                username=user.username,
                first_name=user.first_name,
                last_name=user.last_name
            )
            session.add(db_user)
        else:
            db_user.last_activity = db.get_session_sync().query(func.now()).scalar()
    
    welcome_text = f"""
üé¨ –ü—Ä–∏–≤–µ—Ç, {user.first_name}!

–Ø –±–æ—Ç –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è YouTube –≤–∏–¥–µ–æ. –ü—Ä–æ—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤—å –º–Ω–µ —Å—Å—ã–ª–∫—É –Ω–∞ –≤–∏–¥–µ–æ!

üìã –î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:
/start - –ù–∞—á–∞—Ç—å —Ä–∞–±–æ—Ç—É
/help - –ü–æ–º–æ—â—å
/stats - –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
/status - –°—Ç–∞—Ç—É—Å –∑–∞–≥—Ä—É–∑–æ–∫

‚ö†Ô∏è –ò—Å–ø–æ–ª—å–∑—É–π —Ç–æ–ª—å–∫–æ –¥–ª—è –ª–∏—á–Ω—ã—Ö —Ü–µ–ª–µ–π!
    """
    
    await message.answer(welcome_text)

@router.message(Command("help"))
async def cmd_help(message: types.Message):
    """Handle /help command"""
    help_text = """
üìñ –ö–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –±–æ—Ç–∞:

1Ô∏è‚É£ –û—Ç–ø—Ä–∞–≤—å —Å—Å—ã–ª–∫—É –Ω–∞ YouTube –≤–∏–¥–µ–æ
2Ô∏è‚É£ –í—ã–±–µ—Ä–∏ —Ñ–æ—Ä–º–∞—Ç (MP4, MP3, WebM)
3Ô∏è‚É£ –í—ã–±–µ—Ä–∏ –∫–∞—á–µ—Å—Ç–≤–æ
4Ô∏è‚É£ –î–æ–∂–¥–∏—Å—å –∑–∞–≥—Ä—É–∑–∫–∏

üìã –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã:
‚Ä¢ üé• MP4 - –≤–∏–¥–µ–æ —Ñ–∞–π–ª—ã
‚Ä¢ üéµ MP3 - –∞—É–¥–∏–æ —Ñ–∞–π–ª—ã  
‚Ä¢ üì± WebM - –≤–µ–± –≤–∏–¥–µ–æ

‚ö†Ô∏è –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è:
‚Ä¢ –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä: 50MB
‚Ä¢ –¢–æ–ª—å–∫–æ –¥–ª—è –ª–∏—á–Ω–æ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
‚Ä¢ –ù–µ –Ω–∞—Ä—É—à–∞–π—Ç–µ –∞–≤—Ç–æ—Ä—Å–∫–∏–µ –ø—Ä–∞–≤–∞

üÜò –ï—Å–ª–∏ —á—Ç–æ-—Ç–æ –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç:
‚Ä¢ –ü—Ä–æ–≤–µ—Ä—å –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç—å —Å—Å—ã–ª–∫–∏
‚Ä¢ –ü–æ–ø—Ä–æ–±—É–π –¥—Ä—É–≥–æ–π —Ñ–æ—Ä–º–∞—Ç
‚Ä¢ –û–±—Ä–∞—Ç–∏—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É
    """
    
    await message.answer(help_text)

@router.message(Command("stats"))
async def cmd_stats(message: types.Message):
    """Handle /stats command"""
    user = message.from_user
    if not user:
        await message.answer("‚ùå –û—à–∏–±–∫–∞: –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω")
        return
    
    with db.get_session() as session:
        db_user = session.query(User).filter(User.telegram_id == user.id).first()
        if not db_user:
            await message.answer("‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω")
            return
        
        # Get user statistics
        total_downloads = session.query(DownloadRequest).filter(
            DownloadRequest.user_id == db_user.id,
            DownloadRequest.status == "completed"
        ).count()
        
        recent_downloads = session.query(DownloadRequest).filter(
            DownloadRequest.user_id == db_user.id
        ).order_by(DownloadRequest.created_at.desc()).limit(5).all()
    
    stats_text = f"""
üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user.first_name}:

üì• –í—Å–µ–≥–æ –∑–∞–≥—Ä—É–∑–æ–∫: {total_downloads}
üìÖ –î–∞—Ç–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏: {db_user.created_at.strftime('%d.%m.%Y')}

üïê –ü–æ—Å–ª–µ–¥–Ω–∏–µ –∑–∞–≥—Ä—É–∑–∫–∏:
"""
    
    for download in recent_downloads:
        status = str(download.status)
        if status == "completed":
            status_emoji = "‚úÖ"
        elif status == "processing":
            status_emoji = "‚è≥"
        else:
            status_emoji = "‚ùå"
        stats_text += f"{status_emoji} {download.video_title[:30]}... ({status})\n"
    
    await message.answer(stats_text)

@router.message(Command("status"))
async def cmd_status(message: types.Message):
    """Handle /status command"""
    user = message.from_user
    if not user:
        await message.answer("‚ùå –û—à–∏–±–∫–∞: –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω")
        return
    
    with db.get_session() as session:
        db_user = session.query(User).filter(User.telegram_id == user.id).first()
        if not db_user:
            await message.answer("‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω")
            return
        
        # Get active downloads
        active_downloads = session.query(DownloadRequest).filter(
            DownloadRequest.user_id == db_user.id,
            DownloadRequest.status.in_(["pending", "processing"])
        ).all()
    
    if not active_downloads:
        await message.answer("‚úÖ –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞–≥—Ä—É–∑–æ–∫")
        return
    
    status_text = "‚è≥ –ê–∫—Ç–∏–≤–Ω—ã–µ –∑–∞–≥—Ä—É–∑–∫–∏:\n\n"
    for download in active_downloads:
        status = str(download.status)
        if status == "processing":
            status_emoji = "‚è≥"
        else:
            status_emoji = "üìã"
        status_text += f"{status_emoji} {download.video_title[:30]}... ({status})\n"
    
    await message.answer(status_text)

# Message handlers
@router.message()
async def handle_message(message: types.Message, state: FSMContext):
    """Handle all messages"""
    logger.info(f"Received message: {message.text}")
    
    if not message.text:
        await message.answer("‚ùå –û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ")
        return
        
    text = message.text.strip()
    logger.info(f"Processing text: {text}")
    
    # Check if it's a YouTube URL
    if validate_youtube_url(text):
        logger.info("Valid YouTube URL detected")
        await handle_youtube_url(message, text, state)
    else:
        logger.info("Not a YouTube URL")
        await message.answer(
            "‚ùå –≠—Ç–æ –Ω–µ –ø–æ—Ö–æ–∂–µ –Ω–∞ —Å—Å—ã–ª–∫—É YouTube. "
            "–û—Ç–ø—Ä–∞–≤—å –º–Ω–µ —Å—Å—ã–ª–∫—É –Ω–∞ YouTube –≤–∏–¥–µ–æ –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è."
        )

async def handle_youtube_url(message: types.Message, url: str, state: FSMContext):
    """Handle YouTube URL"""
    logger.info(f"Starting to handle YouTube URL: {url}")
    
    user = message.from_user
    if not user:
        await message.answer("‚ùå –û—à–∏–±–∫–∞: –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω")
        return
    
    # Check rate limiting
    if not await check_rate_limit(user.id):
        await message.answer("‚ö†Ô∏è –°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–æ–≤. –ü–æ–ø—Ä–æ–±—É–π —á–µ—Ä–µ–∑ –º–∏–Ω—É—Ç—É.")
        return
    
    # Get video info
    logger.info("Getting video info...")
    await message.answer("üîç –ü–æ–ª—É—á–∞—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –≤–∏–¥–µ–æ...")
    
    # Get video information
    try:
        video_info = downloader.get_video_info(url)
        if not video_info:
            # –í—Ä–µ–º–µ–Ω–Ω–∞—è –∑–∞–≥–ª—É—à–∫–∞ –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
            video_info = {
                'title': '–¢–µ—Å—Ç–æ–≤–æ–µ –≤–∏–¥–µ–æ',
                'duration': 120,
                'uploader': 'Test Channel'
            }
            logger.info("Using fallback video info")
    except Exception as e:
        logger.error(f"Error getting video info: {e}")
        video_info = {
            'title': '–í–∏–¥–µ–æ (–æ—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è)',
            'duration': 0,
            'uploader': 'Unknown'
        }
    
    if not video_info:
        await message.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –≤–∏–¥–µ–æ. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Å—Å—ã–ª–∫—É.")
        return
    
    logger.info(f"Video info received: {video_info['title']}")
    
    # Save URL to state
    await state.update_data(url=url, video_info=video_info)
    
    # Show format selection
    await message.answer(
        f"üìπ **{video_info['title']}**\n\n"
        f"‚è± –î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: {format_duration(video_info['duration'])}\n"
        f" –ê–≤—Ç–æ—Ä: {video_info['uploader']}\n\n"
        "–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–æ—Ä–º–∞—Ç –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è:",
        reply_markup=get_format_keyboard()
    )
    
    # Set state
    await state.set_state(DownloadStates.waiting_for_format)

async def check_rate_limit(user_id: int) -> bool:
    """Check if user has exceeded rate limit"""
    # Simple rate limiting - can be enhanced with Redis
    return True  # For now, allow all requests

async def main():
    """Main function"""
    logger.info("Starting bot...")
    
    # Include router in dispatcher
    dp.include_router(router)
    
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main()) 